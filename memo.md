
# 識別子

識別子は変数名などに使える。

- `[a-zA-Z_$][a-zA-Z_$0-9]*`

Javaと正確に同じ。ただし予約語は一切なく、ifなども変数名に使用可能。

# 数値系リテラル

## 整数リテラル

- `[0-9][0-9_]*[0-9]`

数字を並べると整数になる。
整数にはJavaのint型による最大値があり、超えることはできない。
コンポジットを使うとlongを生成したりできる。
先頭以外の場所には任意で `_` を挿入できる。
ただし、小数リテラルの一部となる場合はそちらが優先される。

- `1234`
- `1_234`
- `10_000_000_000`

## 小数リテラル

- `[0-9][0-9_]*\.[0-9_]*`

先頭以外の場所ならどこでも `_` を置ける。
途中のドットはアクセス演算子より高優先度でパースされる
小数リテラルが指数付き小数リテラルの一部である場合、そちらが優先される。

- `3.6`
- `3_324_553.632_532_44`

## 指数つき小数リテラル

- `[0-9][0-9_]*\.[0-9_]*[eE][+-]?[0-9_]*`

小数リテラルに指数部がついたら指数リテラルになる。
指数の符号の前後に空白を入れるとただのコンポジットと加減算になる。
符号がない場合も空白を入れると別物になる。
このeとEはIlmenite唯一の予約語であり、形が指数付き小数リテラル形式になっている場合のみコンポジットより優先される。

- `3.6e-7`
- `3.6E7`
- `3.6E+7`

# コンポジット

- `({数値系リテラル}[a-zA-Z]+)+`
- `({数値系リテラル}[a-zA-Z]+)+{数値系リテラル}`

数値系リテラルと英字列を交互に2個以上並べたものがコンポジットになる。
最初は数値系リテラルでなければならない。
単位の表記などに使える。
long型で出したいときなどにも使える。
eとEは指数付き小数リテラルとして解釈可能な場合はそちらを優先する。
コンポジットは関数呼び出しに変換される。

- `100km`
- `3.14E-48km`
- `10yen`
- `10_000_000L`
- `2d6`

# 括弧

- `\({式}\)`
- `\{{式}\}`
- `\[{式}\]`

中には何でも入れられる。
コンテキストによって扱いは様々。
中身が特定の演算子だった場合に特殊な挙動をする場所に通常の式を置くのにも使える。

文コンテキストの `{}` は中身を実行する。
式コンテキストの `{}` は要求型に応じてリストやマップの初期化子となる。

式コンテキストの `[]` はタプルを作る。

# 因子

- `{識別子}`
- `{リテラル}`
- `{コンポジット}`
- `{括弧}`

それ以上分解できない要素（動的文字列やコンポジットは分解できるが）。

# 後置演算子

- `{因子}\({表現}\)`
- `{因子}\{{表現}\}`
- `{因子}\[{表現}\]`
- `{因子}\.{因子}`
- `{因子}#{因子}`
- `{因子}::{因子}`
- `{因子}　({識別子}|{整数リテラル})`
- `{因子}++`
- `{因子}--`

メンバアクセスや配列アクセスなど。
識別子や整数リテラルのようなごく限られたものだけは裸で後置できる。
制御構文はアクセス演算子として実装される。
アクセス演算子列を見つけたとき、左端が特定の識別子だったときに制御構文として呼び出される。
インクリメントも同じレベルである。

- `sin(56)`
- `array[56]`
- `hash{"key"}`
- `list.length`
- `list.add(3)`
- `list::add`
- `List#add`
- `if (a) {b} else if (c) {d} else {e}`
- `C++`

# 前置演算子

- `++{後置演算子}`
- `--{後置演算子}`
- `+{後置演算子}`
- `-{後置演算子}`
- `!{後置演算子}`
- `*{後置演算子}`
- `&{後置演算子}`
- `@{後置演算子}`
- `~{後置演算子}`

前置演算子は後置演算子よりも優先度が低い。
前置インクリメントは符号より優先される。

`&` `*` はポインタの操作を提供する。
ポインタは文を渡すための機能で、その場所のスコープと構文木の中身をオブジェクトとして抽出する。
一部の文法では暗黙にポインタが生成されるが、受け取り側ではポインタとして渡ってくる。
ポインタは遅延評価となる。

`@` はリストやタプルを展開できる。
引数リストや配列の初期化子や代入式の右辺で使うと、 `,` があるかのように振る舞う。

- `-20.5E-8`
- `--a`
- `&variable`
- `*pointer`
- `list(1, 2, 3, @array, 4, 5)`
- `~0x1234`

# 指数演算子

- `{後置演算子} ^ {後置演算子}`

数少ない右優先結合である。
乗除算より高優先度なのだけが取り柄。

- `4 ^ 3 ^ 2`

# 乗除算演算子

- `{指数演算子} * {指数演算子}`
- `{指数演算子} / {指数演算子}`
- `{指数演算子} % {指数演算子}`

普通の乗除算と余り。
文字の繰り返しにも使える。

- `1 * 2 * 3 / 4 / 5 % 6`
- `"a" * 45`
- `"3" * 5`　`"33333"` が得られる

# 加減算演算子

- `{乗除算演算子} + {乗除算演算子}`
- `{乗除算演算子} - {乗除算演算子}`

普通の加減算。
文字に対して加算すると連結する。

- `1 + 2 - 3`
- `"3" + 5`　`"35"` が得られる

# シフト演算子

- `{加減算演算子} << {加減算演算子}`
- `{加減算演算子} >> {加減算演算子}`
- `{加減算演算子} >>> {加減算演算子}`

Javaのものと同じ。
実装によってはストリームに対してwriteするのにも使える。

- `0x01 << 4`

# 比較演算子

- `{シフト演算子} > {シフト演算子}`
- `{シフト演算子} < {シフト演算子}`
- `{シフト演算子} >= {シフト演算子}`
- `{シフト演算子} <= {シフト演算子}`

Ilmeniteの比較演算子は特殊で、連続して記述すると各演算子の左右で評価したもののandを取る。
例えば `3 < 5 < 6` ならば、 `3 < 5 && 5 < 6` のように分解される。
もし最初の比較が偽だった場合、後続の比較は行われない。

- `2 >= 4`
- `i < 100`
- `3 <= x <= 100`

# 等価演算子

- `{比較演算子} == {比較演算子}`
- `{比較演算子} === {比較演算子}`
- `{比較演算子} != {比較演算子}`
- `{比較演算子} !== {比較演算子}`

Javaと違い演算子オーバーロードで上書きできる。
Javaと違いデフォルトではインスタンスが同じかどうかを返さない。
演算子オーバーロードを実装しなければ一致しているかを検証できない。
基本的な型はデフォルトで深い一致を計算できる。

- `a == b`
- `c == d`

# ビット論理積演算子

- `{等価演算子} & {等価演算子}`

# ビット論理和演算子

- `{ビット論理積演算子} | {ビット論理積演算子}`

# 論理積演算子

- `{ビット論理和演算子} && {ビット論理和演算子}`

# 論理和演算子

- `{論理積演算子} || {論理積演算子}`

# 範囲演算子

- `{論理和演算子} ~ {論理和演算子}`
- `{論理和演算子} .. {論理和演算子}`

範囲を表す。
`3 ~ 7` は「3から7の範囲」だが、 `3 .. 7` は「3以上7以下の整数の配列」となる。
`~` の方の末尾が含まれるか否かはそれを適用する先による。
`~` は単に範囲オブジェクトを生成する。

- `r : range(int) = 0 ~ 100;`
- `a : int[] = 0 .. 100;`

# 条件演算子

- `{範囲演算子} ? {範囲演算子} : {範囲演算子}`

後ろ2個の型が異なる場合はObject型になり、等しい場合はその型を返す。
intはlongに暗黙に変換できないので、キャストが必要になる。

- `b : long = a ? (50 : long) : longValue`

# コロン演算子

- `{条件演算子} : {条件演算子}`

右優先結合である。

文コンテキストで出現した場合、右辺が `{}` ならばラベル構文になる。

- `a: { break a; }`

そうでなければ右辺を型と解釈し変数宣言となる。
`=` 演算子が文コンテキストで出現し左辺がコロン演算子だった場合、宣言と代入を合わせて行う。
関数やラムダ式の引数列にも使う。

- `x : double;`
- `x : double = 80.0;`
- `function sin(x : double) { 50 }`
- `x : double -> x ^ 2`

単　`{}` が式コンテキストで呼び出されて、かつ要求型がマップだった場合、内部のコロン演算子はエントリーの列挙に使われる。

- `m : Map(String, int) = {"a": 1, "b": 2.0 : int};`

式中にいきなり現れた場合、キャストに使う。
Javaのキャストと違って結合優先度が猛烈に弱く列挙系以外の中では最弱である。
voidにキャストすると値は消滅する。

- `a : int = 5.0 + a * 2.5 + 4 : int;`
- `c : int = a ? 5.6 : b ? 86.4 : 5 : int;`
- `a : void = 50 : void;`

# カンマ列挙演算子

- `{コロン演算子}, {コロン演算子}, {コロン演算子}`

各項は省略可能。
ただし最低1個はカンマを書かなければただの値となる。
`(1)` はただの1だが、 `(1,)` は要素数が1個の列挙になる。
省略部分の扱いはコンテキストによる。
省略部分を受け取った場合空括弧と同じempty構文木となる。
多くの列挙を受理する場所は単体で与えても要素数が1の列挙と同扱いになる。
末尾の省略項は多くの場合単に無視される。
末尾以外の要素を省略した場合、関数呼び出しであればデフォルトが指定される。

- `1, 2, 3`
- `1, , 3`
- `, , 3, ,`
- `, , , ,`

# ストリーム演算子

- `{カンマ列挙演算子}　! {カンマ列挙演算子}`　for
- `{カンマ列挙演算子}　!? {カンマ列挙演算子}`　filter
- `{カンマ列挙演算子}　!: {カンマ列挙演算子}`　map
- `{カンマ列挙演算子}　=> {カンマ列挙演算子}`　apply

ストリームや配列に対して処理を行う演算子。
左優先結合。
これらの演算子はすべて右辺が遅延評価される。

```
array : int[] = 0 ~ 10
  !? _ % 2 == 0
  !: _ * 0.1;
array ! System.out.println(_);
```

`=>` は単に右辺の式に左辺を適用するだけで、特にストリーム固有の演算子でもない。
見た目が綺麗に揃うだけの効果である。

- `a : double = sin(50);`
- `a : double = 50 => sin(_);`
- `1, 2, 3, @(4 .. 8), 9, 10 => sum(_)`　= 55

- `1 .. 5 !: "a" * _ => join(",")`　→`a,aa,aaa,aaaa,aaaaa`

# 代入演算子

- `{ストリーム演算子} = {ストリーム演算子}`
- `{ストリーム演算子} ^= {ストリーム演算子}`
- `{ストリーム演算子} *= {ストリーム演算子}`
- `{ストリーム演算子} /= {ストリーム演算子}`
- `{ストリーム演算子} %= {ストリーム演算子}`
- `{ストリーム演算子} += {ストリーム演算子}`
- `{ストリーム演算子} -= {ストリーム演算子}`
- `{ストリーム演算子} <<= {ストリーム演算子}`
- `{ストリーム演算子} >>= {ストリーム演算子}`
- `{ストリーム演算子} >>>= {ストリーム演算子}`
- `{ストリーム演算子} &= {ストリーム演算子}`
- `{ストリーム演算子} |= {ストリーム演算子}`
- `{ストリーム演算子} &&= {ストリーム演算子}`
- `{ストリーム演算子} |= {ストリーム演算子}`
- `{ストリーム演算子} -> {ストリーム演算子}`
- `{ストリーム演算子} -> {ストリーム演算子}`

演算代入は中置演算子のうち一部の計算系のものにしかない。
代入系演算子は代入後の左辺を返す。

ラムダ式は代入と同じレベルになる。
式コンテキストの要求型がラムダ式型であれば自動的に補完される。

- `b : int; f : Object = a : int -> (b = a) : void;`
- `b : int; f : (int -> void) = a -> b = a;`
- `f : (int, double -> [String, int]) = a : int, b : double -> ["" + b, a]`

ラムダ式は複数の戻り値は持てない。
タプルと代入式側の仕様で疑似的に複数の戻り値を返すことは可能。
代入の左辺が `[]` だった場合、左辺の各項に右辺のタプルを展開して与える。
左辺が変数宣言でもよい。

- `a : int; [a, b : int] = (f : (() -> [int, int]))();`

値を取らないラムダ式・値を返さないラムダ式はその部分をvoidにする。
空の `()` はvoidと同じ意味である。
空の `[]` は要素数が0のタプルであってvoidではない。

- `counter : int = 0; count : (void -> void) = void -> counter++ : void`
- `counter : int = 0; count : (void -> void) = () -> counter++ : ()`
- `counter : int = 0; count : (() -> ()) = void -> counter++ : void`

# セミコロン列挙演算子

- `{代入演算子}; {代入演算子}; {代入演算子}`

基本はカンマ列挙演算子と同じ。
個々の要素は省略できる。
末尾のセミコロンは省略できる。

式コンテキストの `()` の中に現れることもできる。
その場合最後の要素の値が返される。
末尾のセミコロンは単に無視される。
要素が1個もない場合はvoidになる。

- `a : int = (b : int = 50; b += 100; b);`
- `a : void = ();`
- `a : void = (;);`








# 型

Javaの型と似ている。

- byte
- short
- int
- long
- float
- double
- char
- boolean
- T[]　　リスト
- map(T, T)
- [A, B, C, …]　　タプル
- (A, B, C, …) -> (D, E, F, …)　　ラムダ式
- range(T)
- stream(T)
- type
- struct(name1 : A, name2 : B, …)
- null
- void
- Object

voidは引数や戻り値を持たないことを表す特殊な型である。

Objectはvoid以外のすべてからキャストできる。
ただしプリミティブ型はボクシングされる。

voidはあらゆる型からキャストできるが、値は消える。
voidから他の型へはキャストできない。
戻り値型がvoidの式は文コンテキストからしか呼び出すことができない。









